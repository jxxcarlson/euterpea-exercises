Space Invasion: An Exercise in 3-Part Aleatory Composition.

*James Carlson*

*November 18, 2020*


> module SpaceInvasion where
> import Euterpea
> import System.Random



The code here is based on that of Donya Quick:

   [DQ](https://github.com/Euterpea/Euterpea2-Examples/blob/master/NoteLevel/RandomMusic.lhs)

The new elememnts are

- Use of random walk (Brown noise) in addition to uniformly distributed random numbers (white noise).
- Division of some of the voices in to sections

Aside from these, the overall structure of the composition is as in [DQ]: three voices
in parallel played by percussion instruments, with melodies generated by a random process.
We use 

White noise

Two functions from [DQ]: the randInts function constructs an infinite series of random 
Ints from a seed.  

> randInts :: Int -> [Int]
> randInts seed = recInts (mkStdGen seed) where
>     recInts g = let (i,g') = next g in i : recInts g'

randIntsRange maps the sequence of integers generated by randInts
into a specified range:

> randIntsRange :: (Int, Int) -> Int -> [Int]
> randIntsRange (lower, upper) = 
>     map (\i -> (i `mod` (upper-lower)) + lower) . randInts 


Brown noise 

The next function prouduces an infinite random walk with given seed:
  
> randomWalk :: Int -> [Int]
> randomWalk seed = recInts seed (mkStdGen seed) where
>     recInts current g = let 
>                             (i,g') = next g 
>                             delta = 2 * (mod i 2) - 1
>                             current' = current + delta
>                           in current' : recInts current' g'

More the point here is a infiniite random walk of bounded range with given starting value, step, and seed:

> magicNumber = 3000

> boundedRandomWalk :: (Int, Int) -> Int -> Int -> Int -> [Int]
> boundedRandomWalk (lowerBound, upperBound) start step seed = recInts (seed + magicNumber) (mkStdGen seed) where
>     recInts current g = let 
>                             (i,g') = next g 
>                             delta = (2 * (mod i 2) - 1) * step
>                             current' = bounce (lowerBound, upperBound) start step $ current + delta
>                           in current' : recInts current' g'


The bounce function maps an input k to the interval [lowerBound, upperBound].  If k is less than lowerbound,
it is mapped to lowerBound + step.  If it is greater than upperBound but less than or equal to magicNumber,
is mapped to upperBound - step.  It it exceeds magicNumber it is mapped to start.

> bounce :: (Int, Int) -> Int -> Int -> Int -> Int
> bounce (lowerBound, upperBound) start step k = 
>   if k > magicNumber then start else if k > upperBound then upperBound - step else if k < lowerBound then lowerBound + step else  k


Generating MUsic

Genrerate music from white noise:

> melGen1 :: (Int, Int) -> Int -> Music (Pitch, Volume)
> melGen1 (lowerBound, upperBound) s = 
>     let pitches = map pitch $ randIntsRange (lowerBound, upperBound) s
>         vols = randIntsRange (60,120) (s+1)
>     in  line $ map (note sn) $ zip pitches vols


Genrerate music from brown noise:

> melGen2 :: (Int, Int) -> Int -> Int -> Int -> Music (Pitch, Volume)
> melGen2 (lowerBound, upperBound) start step seed = 
>     let pitches = map pitch $ boundedRandomWalk (lowerBound, upperBound) start step seed
>         vols = randIntsRange (60,120) (seed + 1)
>     in  line $ map (note sn) $ zip pitches vols


From [DQ], functions to modify the performance:

> rit r = Modify (Phrase [Tmp $ Ritardando r])
> acc a = Modify (Phrase [Tmp $ Accelerando a])
> dim d = Modify (Phrase [Dyn $ Diminuendo d])
> cre c = Modify (Phrase [Dyn $ Crescendo c])

The piece:

> xylophone :: Dur -> Int -> Int -> Dur -> Dur -> Int -> Music (Pitch, Volume)
> xylophone  n l h d r s = instrument Xylophone $ dim d $ rit r $ cut n $ melGen1 (l, h) (345 + s)

> marimba :: Dur -> Int -> Music (Pitch, Volume)
> marimba n s = instrument Marimba $ cre 0.5 $ acc 0.4  $ cut n $ melGen2 (30, 80) 30 2 (234 + s)

> tubularBells n l h s = instrument TubularBells $ cut n $ melGen2 (l, h) 45 4 (789 + s)

> xylo s = xylophone 5 10 110 0 0 s :+: rest 2 :+: xylophone (2 + hn) 10 110 0.5 0.5 (2 * s)
> bells s = rest 1 :+: tubularBells 2 30 60 s :+: rest 1 :+: tubularBells 2 20 100 (2 * s)

> spaceInvasion s = chord [xylo s, bells s, marimba 12 s]